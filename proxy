#!/usr/bin/python

import socket
import select
import time
import sys
import threading
from copy import deepcopy

def forward(data):
	headers = parseHeader(deepcopy(data[:data.find('\r\n\r\n')]))
	print headers
	if "Content-Length" in headers:
		body = data[data.find('\r\n\r\n')+4:data.find('\r\n\r\n')+4+int(headers['Content-Length'])]
	else:
		body = ""

def parseHeader(data):
	fields = data.split('\r\n')
	options = {"request":fields[0]}
	for op in fields[1:]:
		key, field = op[:op.find(':')], op[op.find(':')+2:]
		if key != '' and field != '':
			options[key] = field
	return options

def listen(server):
	inputs = [server]
	outputs = []
	queue = []
	while True:
		readable, writable, exceptional = select.select(inputs, outputs, [])

		for s in readable:
			if s is server:
				connection, client_address = s.accept()
				connection.setblocking(0)
				inputs.append(connection)

			else:
				# recv data up to 1024 bytes
				data = s.recv(4096)
				t = threading.Thread(target=forward, args=(data,))
				t.daemon = True
				t.start()

				# remove inputs so next select call does not read it again
				inputs.remove(s)
				# close socket that select intercepted and that we were reading from
				s.close()

# set socket for the server to listen on
def set_sockets(host, port):
	server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	server.setblocking(0)

	server_address = (host, port)
	print >>sys.stderr, 'starting up on %s port %s' % server_address
	server.bind(server_address)

	server.listen(5)

	return server

if __name__ == '__main__':
	try:
		server = set_sockets('localhost', 8080)

		listen(server)
	except KeyboardInterrupt:
		print('ctrl-c exit')
		sys.exit(0)